/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -verify -bundle WasmSupport -no-prefix Ring ../Ring.fst
  F* version: b55bb590
  KreMLin version: 2f843633
 */

#include "Ring.h"

void host_memory_region()
{
  
}

void enclave_memory_region()
{
  
}

int8_t read_host_memory(int8_t *host_buffer, uint32_t addr)
{
  return (int8_t)0;
}

uint32_t incr_ht(uint32_t ht, uint32_t rsize)
{
  uint32_t ht_ = ht + (uint32_t)1U;
  if (ht_ == rsize)
    return (uint32_t)0U;
  else
    return ht_;
}

int32_t *create_host_memory__int32_t(int32_t init1, uint32_t size)
{
  KRML_CHECK_SIZE(sizeof (int32_t), size);
  int32_t *buf = KRML_HOST_MALLOC(sizeof (int32_t) * size);
  for (uint32_t _i = 0U; _i < size; ++_i)
    buf[_i] = init1;
  return buf;
}

int32_t *create_enclave_memory__int32_t(int32_t init1, uint32_t size)
{
  KRML_CHECK_SIZE(sizeof (int32_t), size);
  int32_t *buf = KRML_HOST_MALLOC(sizeof (int32_t) * size);
  for (uint32_t _i = 0U; _i < size; ++_i)
    buf[_i] = init1;
  return buf;
}

bool is_rb_full__int32_t(ringstruct__int32_t r)
{
  return r.head + (uint32_t)1U == r.tail;
}

K___Ring_ringstruct__int32_t_bool push__int32_t(ringstruct__int32_t r, int32_t v1)
{
  bool b = is_rb_full__int32_t(r);
  if (!b)
  {
    uint32_t head_ = incr_ht(r.head, r.rsize);
    ringstruct__int32_t uu____0 = r;
    ringstruct__int32_t
    r_ = { .rbuf = uu____0.rbuf, .head = head_, .tail = uu____0.tail, .rsize = uu____0.rsize };
    r_.rbuf[r_.head] = v1;
    return ((K___Ring_ringstruct__int32_t_bool){ .fst = r_, .snd = true });
  }
  else
    return ((K___Ring_ringstruct__int32_t_bool){ .fst = r, .snd = false });
}

bool is_rb_empty__int32_t(ringstruct__int32_t r)
{
  return r.head == r.tail;
}

K___Ring_ringstruct__int32_t_Ring_option__int32_t pop__int32_t(ringstruct__int32_t r)
{
  bool b = is_rb_empty__int32_t(r);
  if (!b)
  {
    uint32_t tail_ = incr_ht(r.tail, r.rsize);
    ringstruct__int32_t uu____0 = r;
    ringstruct__int32_t
    r_ = { .rbuf = uu____0.rbuf, .head = uu____0.head, .tail = tail_, .rsize = uu____0.rsize };
    int32_t v1 = r_.rbuf[r_.tail];
    return
      (
        (K___Ring_ringstruct__int32_t_Ring_option__int32_t){
          .fst = r_,
          .snd = { .tag = Value, .v = v1 }
        }
      );
  }
  else
    return
      ((K___Ring_ringstruct__int32_t_Ring_option__int32_t){ .fst = r, .snd = { .tag = Error } });
}

option__int32_t test_ringbuffer()
{
  host_memory_region();
  int32_t *host_memory = create_host_memory__int32_t((int32_t)0, (uint32_t)256U);
  enclave_memory_region();
  int32_t *enclave_memory = create_enclave_memory__int32_t((int32_t)0, (uint32_t)128U);
  uint32_t rlen = (uint32_t)32U;
  int32_t rinit = (int32_t)1;
  KRML_CHECK_SIZE(sizeof (int32_t), rlen);
  int32_t *buf = KRML_HOST_MALLOC(sizeof (int32_t) * rlen);
  for (uint32_t _i = 0U; _i < rlen; ++_i)
    buf[_i] = rinit;
  ringstruct__int32_t
  rb = { .rbuf = buf, .head = (uint32_t)0U, .tail = (uint32_t)0U, .rsize = rlen };
  K___Ring_ringstruct__int32_t_bool scrut = push__int32_t(rb, (int32_t)16);
  ringstruct__int32_t rb_ = scrut.fst;
  bool status = scrut.snd;
  if (status)
  {
    K___Ring_ringstruct__int32_t_Ring_option__int32_t scrut = pop__int32_t(rb_);
    return scrut.snd;
  }
  else
    return ((option__int32_t){ .tag = Error });
}

int32_t main()
{
  option__int32_t uu____0 = test_ringbuffer();
  return (int32_t)0;
}

