/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -verify -skip-compilation -bundle WasmSupport ../Writer.fst -I ../
  F* version: b55bb590
  KreMLin version: 2f843633
 */

#include "FStar.h"

typedef struct Prims_list__bool_s Prims_list__bool;

#define Prims_Nil 0
#define Prims_Cons 1

typedef uint8_t Prims_list__bool_tags;

typedef struct Prims_list__bool_s
{
  Prims_list__bool_tags tag;
  bool hd;
  Prims_list__bool *tl;
}
Prims_list__bool;

#define FStar_Seq_Base_MkSeq 0

typedef uint8_t FStar_Seq_Base_seq__bool_tags;

typedef Prims_list__bool *FStar_Seq_Base_seq__bool;

static Prims_list__bool *FStar_Seq_Base_cons__bool(bool x, Prims_list__bool *s)
{
  KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
  Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
  buf[0U] = ((Prims_list__bool){ .tag = Prims_Cons, .hd = x, .tl = s });
  return buf;
}

static Prims_list__bool *FStar_Seq_Base_create__bool(Prims_int len, bool v)
{
  if (len == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
    Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
    buf[0U] = ((Prims_list__bool){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__bool(v,
        FStar_Seq_Base_create__bool(Prims_op_Subtraction(len, (krml_checked_int_t)1), v));
}

static bool FStar_List_Tot_Base_hd__bool(Prims_list__bool *uu___0_39)
{
  if (uu___0_39->tag == Prims_Cons)
    return uu___0_39->hd;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__bool *FStar_List_Tot_Base_tail__bool(Prims_list__bool *uu___1_64)
{
  if (uu___1_64->tag == Prims_Cons)
    return uu___1_64->tl;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__bool
*(*FStar_List_Tot_Base_tl__bool)(Prims_list__bool *x0) = FStar_List_Tot_Base_tail__bool;

static bool FStar_List_Tot_Base_index__bool(Prims_list__bool *l, Prims_int i)
{
  if (i == (krml_checked_int_t)0)
    return FStar_List_Tot_Base_hd__bool(l);
  else
    return
      FStar_List_Tot_Base_index__bool(FStar_List_Tot_Base_tl__bool(l),
        Prims_op_Subtraction(i, (krml_checked_int_t)1));
}

static bool FStar_Seq_Base_index__bool(Prims_list__bool *s, Prims_int i)
{
  return FStar_List_Tot_Base_index__bool(s, i);
}

static Prims_list__bool
*FStar_List_Tot_Base_append__bool(Prims_list__bool *x, Prims_list__bool *y)
{
  if (x->tag == Prims_Nil)
    return y;
  else if (x->tag == Prims_Cons)
  {
    Prims_list__bool *tl1 = x->tl;
    bool a = x->hd;
    KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
    Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
    buf[0U]
    =
      (
        (Prims_list__bool){
          .tag = Prims_Cons,
          .hd = a,
          .tl = FStar_List_Tot_Base_append__bool(tl1, y)
        }
      );
    return buf;
  }
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Prims_list__bool
*FStar_Seq_Base_append__bool(Prims_list__bool *s1, Prims_list__bool *s2)
{
  return FStar_List_Tot_Base_append__bool(s1, s2);
}

static Prims_list__bool *FStar_Seq_Base_tl__bool(Prims_list__bool *s)
{
  return FStar_List_Tot_Base_tl__bool(s);
}

static bool FStar_Seq_Base_hd__bool(Prims_list__bool *s)
{
  return FStar_List_Tot_Base_hd__bool(s);
}

static Prims_list__bool
*FStar_Seq_Base_slice__bool(Prims_list__bool *s, Prims_int i, Prims_int j)
{
  if (Prims_op_GreaterThan(i, (krml_checked_int_t)0))
    return
      FStar_Seq_Base_slice__bool(FStar_Seq_Base_tl__bool(s),
        Prims_op_Subtraction(i, (krml_checked_int_t)1),
        Prims_op_Subtraction(j, (krml_checked_int_t)1));
  else if (j == (krml_checked_int_t)0)
  {
    KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
    Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
    buf[0U] = ((Prims_list__bool){ .tag = Prims_Nil });
    return buf;
  }
  else
    return
      FStar_Seq_Base_cons__bool(FStar_Seq_Base_hd__bool(s),
        FStar_Seq_Base_slice__bool(FStar_Seq_Base_tl__bool(s),
          i,
          Prims_op_Subtraction(j, (krml_checked_int_t)1)));
}

static Prims_list__bool
*FStar_BitVector_logand_vec(Prims_pos n, Prims_list__bool *a, Prims_list__bool *b)
{
  if (n == (krml_checked_int_t)1)
    return
      FStar_Seq_Base_create__bool((krml_checked_int_t)1,
        FStar_Seq_Base_index__bool(a,
          (krml_checked_int_t)0)
        && FStar_Seq_Base_index__bool(b, (krml_checked_int_t)0));
  else
    return
      FStar_Seq_Base_append__bool(FStar_Seq_Base_create__bool((krml_checked_int_t)1,
          FStar_Seq_Base_index__bool(a,
            (krml_checked_int_t)0)
          && FStar_Seq_Base_index__bool(b, (krml_checked_int_t)0)),
        FStar_BitVector_logand_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
          FStar_Seq_Base_slice__bool(a, (krml_checked_int_t)1, n),
          FStar_Seq_Base_slice__bool(b, (krml_checked_int_t)1, n)));
}

Prims_int FStar_UInt_max_int(Prims_int n)
{
  return Prims_op_Subtraction(Prims_pow2(n), (krml_checked_int_t)1);
}

static Prims_list__bool *FStar_Seq_Base_empty__bool()
{
  KRML_CHECK_SIZE(sizeof (Prims_list__bool), (uint32_t)1U);
  Prims_list__bool *buf = KRML_HOST_MALLOC(sizeof (Prims_list__bool));
  buf[0U] = ((Prims_list__bool){ .tag = Prims_Nil });
  return buf;
}

static Prims_list__bool *FStar_UInt_to_vec(Prims_int n, Prims_int num)
{
  if (n == (krml_checked_int_t)0)
    return FStar_Seq_Base_empty__bool();
  else
    return
      FStar_Seq_Base_append__bool(FStar_UInt_to_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
          Prims_op_Division(num, (krml_checked_int_t)2)),
        FStar_Seq_Base_create__bool((krml_checked_int_t)1,
          Prims_op_Modulus(num, (krml_checked_int_t)2) == (krml_checked_int_t)1));
}

static Prims_int FStar_UInt_from_vec(Prims_int n, Prims_list__bool *vec)
{
  if (n == (krml_checked_int_t)0)
    return (krml_checked_int_t)0;
  else
  {
    krml_checked_int_t ite;
    if (FStar_Seq_Base_index__bool(vec, Prims_op_Subtraction(n, (krml_checked_int_t)1)))
      ite = (krml_checked_int_t)1;
    else
      ite = (krml_checked_int_t)0;
    return
      Prims_op_Addition(Prims_op_Multiply((krml_checked_int_t)2,
          FStar_UInt_from_vec(Prims_op_Subtraction(n, (krml_checked_int_t)1),
            FStar_Seq_Base_slice__bool(vec,
              (krml_checked_int_t)0,
              Prims_op_Subtraction(n, (krml_checked_int_t)1)))),
        ite);
  }
}

Prims_int FStar_UInt_logand(Prims_pos n, Prims_int a, Prims_int b)
{
  return
    FStar_UInt_from_vec(n,
      FStar_BitVector_logand_vec(n, FStar_UInt_to_vec(n, a), FStar_UInt_to_vec(n, b)));
}

