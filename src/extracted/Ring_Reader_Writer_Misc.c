/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: krml -tmpdir extracted -verify -skip-compilation -bundle WasmSupport -bundle Ring+Reader+Writer+Misc= Ring.fst Reader.fst Writer.fst Misc.fst
  F* version: b6f857f3
  KreMLin version: 508d64eb
 */

#include "Ring_Reader_Writer_Misc.h"

bool Ring_is_rb_full(uint32_t rsize, uint32_t head1, uint32_t tail1)
{
  return head1 + (uint32_t)1U == tail1;
}

bool Ring_is_rb_empty(uint32_t rsize, uint32_t head1, uint32_t tail1)
{
  return head1 == tail1;
}

uint32_t Ring_incr_ht(uint32_t ht, uint32_t rsize)
{
  uint32_t ht_ = ht + (uint32_t)1U;
  if (ht_ == rsize)
    return (uint32_t)0U;
  else
    return ht_;
}

uint32_t Ring_get_current_size(uint32_t head1, uint32_t tail1, uint32_t rsize)
{
  if (head1 >= tail1)
    return head1 - tail1;
  else
    return rsize - (tail1 - head1);
}

uint32_t Ring_get_remaining_space(uint32_t head1, uint32_t tail1, uint32_t rsize)
{
  uint32_t c = Ring_get_current_size(head1, tail1, rsize);
  return rsize - c;
}

Ring_ringstruct__uint8_t Ring_init__uint8_t(uint8_t i, uint32_t s)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), s);
  uint8_t *buf0 = KRML_HOST_MALLOC(sizeof (uint8_t) * s);
  for (uint32_t _i = 0U; _i < s; ++_i)
    buf0[_i] = i;
  uint32_t *buf1 = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
  uint32_t *buf = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
  return
    ((Ring_ringstruct__uint8_t){ .rbuf = buf0, .headptr = buf1, .tailptr = buf, .rsize = s });
}

void Ring_push__uint8_t(Ring_ringstruct__uint8_t r, uint8_t v1)
{
  uint32_t rsize = r.rsize;
  uint32_t head1 = *r.headptr;
  *r.headptr = Ring_incr_ht(head1, rsize);
  r.rbuf[head1] = v1;
}

uint8_t Ring_pop__uint8_t(Ring_ringstruct__uint8_t r)
{
  uint32_t rsize = r.rsize;
  uint32_t tail1 = *r.tailptr;
  *r.tailptr = Ring_incr_ht(tail1, rsize);
  return r.rbuf[tail1];
}

void Ring_push2__uint8_t(Ring_ringstruct__uint8_t r, uint8_t v1, uint8_t v2)
{
  Ring_push__uint8_t(r, v1);
  Ring_push__uint8_t(r, v2);
}

uint8_t Ring_test_ringbuffer()
{
  uint32_t rlen = (uint32_t)32U;
  uint8_t rinit = (uint8_t)1U;
  Ring_ringstruct__uint8_t rb = Ring_init__uint8_t(rinit, rlen);
  Ring_push__uint8_t(rb, (uint8_t)3U);
  uint8_t uu____0 = Ring_pop__uint8_t(rb);
  Ring_push__uint8_t(rb, (uint8_t)4U);
  uint8_t v1 = Ring_pop__uint8_t(rb);
  Ring_push2__uint8_t(rb, (uint8_t)5U, (uint8_t)6U);
  return v1;
}

Ring_ringstruct__uint8_t Reader_init(uint32_t s)
{
  return Ring_init__uint8_t((uint8_t)0U, s);
}

K___uint8_t_uint8_t_uint8_t_uint8_t Ring_pop4__uint8_t(Ring_ringstruct__uint8_t r)
{
  uint8_t m1 = Ring_pop__uint8_t(r);
  uint8_t m2 = Ring_pop__uint8_t(r);
  uint8_t m3 = Ring_pop__uint8_t(r);
  uint8_t m4 = Ring_pop__uint8_t(r);
  return ((K___uint8_t_uint8_t_uint8_t_uint8_t){ .fst = m1, .snd = m2, .thd = m3, .f3 = m4 });
}

bool Ring_is_dword_poppable__uint8_t(Ring_ringstruct__uint8_t r)
{
  uint32_t head1 = *r.headptr;
  uint32_t tail1 = *r.tailptr;
  uint32_t rsize = r.rsize;
  uint32_t space = Ring_get_current_size(head1, tail1, rsize);
  if (space >= (uint32_t)4U)
    return true;
  else
    return false;
}

bool Ring_is_poppable__uint8_t(Ring_ringstruct__uint8_t r)
{
  uint32_t head1 = *r.headptr;
  uint32_t tail1 = *r.tailptr;
  uint32_t rsize = r.rsize;
  uint32_t space = Ring_get_current_size(head1, tail1, rsize);
  if (space > (uint32_t)0U)
    return true;
  else
    return false;
}

uint32_t
Reader_read(Ring_ringstruct__uint8_t r, uint32_t (*f)(uint32_t x0, uint8_t *x1, uint64_t x2))
{
  K___uint8_t_uint8_t_uint8_t_uint8_t scrut = Ring_pop4__uint8_t(r);
  uint8_t h1 = scrut.fst;
  uint8_t h2 = scrut.snd;
  uint8_t h3 = scrut.thd;
  uint8_t h4 = scrut.f3;
  uint32_t len = Misc_make_double_word(h1, h2, h3, h4);
  bool canpop_dword = Ring_is_dword_poppable__uint8_t(r);
  if (canpop_dword)
  {
    K___uint8_t_uint8_t_uint8_t_uint8_t scrut = Ring_pop4__uint8_t(r);
    uint8_t m1 = scrut.fst;
    uint8_t m2 = scrut.snd;
    uint8_t m3 = scrut.thd;
    uint8_t m4 = scrut.f3;
    uint32_t m = Misc_make_double_word(m1, m2, m3, m4);
    bool canpop_ = Ring_is_poppable__uint8_t(r);
    if (canpop_)
    {
      uint8_t d = Ring_pop__uint8_t(r);
      uint8_t *dptr = KRML_HOST_MALLOC(sizeof (uint8_t));
      dptr[0U] = d;
      uint32_t s = f(m, dptr, (uint64_t)1U);
      return s;
    }
    else
      return (uint32_t)0U;
  }
  else
    return (uint32_t)0U;
}

void Writer_write(Ring_ringstruct__uint8_t r, uint8_t v1)
{
  Ring_push__uint8_t(r, v1);
}

uint32_t Misc_myshift(uint8_t h, uint32_t m)
{
  return (uint32_t)h * m;
}

uint32_t Misc_make_double_word(uint8_t h1, uint8_t h2, uint8_t h3, uint8_t h4)
{
  uint32_t a1 = Misc_myshift(h1, (uint32_t)16777216U);
  uint32_t a2 = Misc_myshift(h1, (uint32_t)65536U);
  uint32_t a3 = Misc_myshift(h1, (uint32_t)256U);
  uint32_t a4 = Misc_myshift(h1, (uint32_t)1U);
  uint32_t a5 = a2 + a3;
  uint32_t a6 = a5 + a4;
  return a1 + a6;
}

